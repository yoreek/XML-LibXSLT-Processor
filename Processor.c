/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2205 from the
 * contents of Processor.xs. Do not edit this file, edit Processor.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Processor.xs"
#include "EXTERN.h"
#include "perl.h"
#define NO_XSLOCKS
#include "XSUB.h"
#include "ppport.h"

#include <libxsltp/xsltp_config.h>
#include <libxsltp/xsltp_core.h>
#include <libxsltp/xsltp.h>

#include <libxslt/imports.h>

#define MAX_TRANSFORMATIONS        16
#define MAX_TRANSFORMATIONS_PARAMS 254

struct _TransformCtxt {
    char *stylesheet;
    char *params[MAX_TRANSFORMATIONS_PARAMS + 1];
};
typedef struct _TransformCtxt TransformCtxt;

#define Pmm_NO_PSVI 0
#define Pmm_PSVI_TAINTED 1

struct _ProxyNode {
    xmlNodePtr node;
    xmlNodePtr owner;
    int count;
};

struct _DocProxyNode {
    xmlNodePtr node;
    xmlNodePtr owner;
    int count;
    int encoding; /* only used for proxies of xmlDocPtr */
    int psvi_status; /* see below ... */
};

/* helper type for the proxy structure */
typedef struct _DocProxyNode DocProxyNode;
typedef struct _ProxyNode ProxyNode;

/* pointer to the proxy structure */
typedef ProxyNode* ProxyNodePtr;
typedef DocProxyNode* DocProxyNodePtr;

/* this my go only into the header used by the xs */
#define SvPROXYNODE(x) (INT2PTR(ProxyNodePtr,SvIV(SvRV(x))))
#define PmmPROXYNODE(x) (INT2PTR(ProxyNodePtr,x->_private))
#define SvNAMESPACE(x) (INT2PTR(xmlNsPtr,SvIV(SvRV(x))))

#define x_PmmREFCNT(node)      node->count
#define x_PmmREFCNT_inc(node)  node->count++
#define x_PmmNODE(xnode)       xnode->node
#define x_PmmOWNER(node)       node->owner
#define x_PmmOWNERPO(node)     ((node && x_PmmOWNER(node)) ? (ProxyNodePtr)x_PmmOWNER(node)->_private : node)

#define x_PmmENCODING(node)    ((DocProxyNodePtr)(node))->encoding
#define x_PmmNodeEncoding(node) ((DocProxyNodePtr)(node->_private))->encoding

#define x_SetPmmENCODING(node,code) x_PmmENCODING(node)=(code)
#define x_SetPmmNodeEncoding(node,code) x_PmmNodeEncoding(node)=(code)

#define x_PmmSvNode(n) x_PmmSvNodeExt(n,1)

ProxyNodePtr
x_PmmNewNode(xmlNodePtr node);

ProxyNodePtr
x_PmmNewFragment(xmlDocPtr document);

SV*
x_PmmCreateDocNode( unsigned int type, ProxyNodePtr pdoc, ...);

int
x_PmmREFCNT_dec( ProxyNodePtr node );

SV*
x_PmmNodeToSv( xmlNodePtr node, ProxyNodePtr owner );

#ifdef XS_WARNINGS
#define xs_warn(string) warn(string)
/* #define xs_warn(string) fprintf(stderr, string) */
#else
#define xs_warn(string)
#endif

/* extracts the libxml2 node from a perl reference
 */

xmlNodePtr
x_PmmSvNodeExt( SV* perlnode, int copy )
{
    xmlNodePtr retval = NULL;
    ProxyNodePtr proxy = NULL;

    if ( perlnode != NULL && perlnode != &PL_sv_undef ) {
        if ( sv_derived_from(perlnode, "XML::LibXML::Node")  ) {
            proxy = SvPROXYNODE(perlnode);
            if ( proxy != NULL ) {
                xs_warn( "x_PmmSvNodeExt:   is a xmlNodePtr structure\n" );
                retval = x_PmmNODE( proxy ) ;
            }

            if ( retval != NULL
                 && ((ProxyNodePtr)retval->_private) != proxy ) {
                xs_warn( "x_PmmSvNodeExt:   no node in proxy node\n" );
                x_PmmNODE( proxy ) = NULL;
                retval = NULL;
            }
        }
    }

    return retval;
}

int
Processor_write_scalar(void * context, const char * buffer, int len) {
    SV * scalar;

    scalar = (SV *)context;

    sv_catpvn(scalar, (const char*)buffer, len);

    return len;
}

int
Processor_write_handler(void *fp, char *buffer, int len)
{
    if ( buffer != NULL && len > 0)
        PerlIO_write(fp, buffer, len);

    return len;
}

int
Processor_write_tied_handler(void *obj, char *buffer, int len)
{
    if ( buffer != NULL && len > 0) {
        dSP;

        ENTER;
        SAVETMPS;

        PUSHMARK(SP);
        EXTEND(SP, 2);
        PUSHs((SV *)obj);
        PUSHs(sv_2mortal(newSVpv(buffer, len)));
        PUTBACK;

        call_method("PRINT", G_SCALAR);

        FREETMPS;
        LEAVE;
    }

    return len;
}

int
Processor_close_handler(void *fh)
{
    return 1;
}

#line 177 "Processor.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 229 "Processor.c"

XS(XS_XML__LibXSLT__Processor_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_XML__LibXSLT__Processor_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	class;
#line 175 "Processor.xs"
        xsltp_t *processor;
        int      i;
        char    *p;
        SV      *v;
#line 247 "Processor.c"
	xsltp_t *	RETVAL;

	if (items < 1)
	    class = "XML::LibXSLT::Processor";
	else {
	    class = (char *)SvPV_nolen(ST(0));
	}
#line 180 "Processor.xs"
        if ((processor = xsltp_create()) == NULL) {
            croak("Malloc error in new()");
        }

        /* parse parameters */
        if (items > 1) {
            if ((items - 1) % 2 != 0) {
                croak("Odd parameters in new()");
            }
            for (i = 1; i < items; i = i + 2) {
                if (!SvOK(ST(i))) {
                    croak("Parameter name is undefined");
                }

                p = (char *) SvPV(ST(i), PL_na);
                v = ST(i + 1);
                if (!SvOK(v)) {
                    croak("Parameter '%s' is undefined", p);
                }

                if (strcmp(p, "stylesheet_max_depth") == 0) {
                    processor->stylesheet_max_depth = SvIV(v);
                }
                else if (strcmp(p, "stylesheet_caching_enable") == 0) {
                    processor->stylesheet_caching_enable = SvIV(v);
                }
                else if (strcmp(p, "document_caching_enable") == 0) {
                    processor->document_caching_enable = SvIV(v);
                }
                else if (strcmp(p, "keys_caching_enable") == 0) {
                    processor->keys_caching_enable = SvIV(v);
                }
                else if (strcmp(p, "profiler_enable") == 0) {
                    processor->profiler_enable = SvIV(v);
                }
                else if (strcmp(p, "profiler_stylesheet") == 0) {
                    processor->profiler_stylesheet = SvPV_nolen(v);
                }
                else if (strcmp(p, "profiler_repeat") == 0) {
                    processor->profiler_repeat = SvIV(v);
                }
                else {
                    croak("Invalid parameter '%s'", p);
                }
            }
        }

        RETVAL = processor;
#line 304 "Processor.c"
	ST(0) = sv_newmortal();
    sv_setref_pv(ST(0), "XML::LibXSLT::Processor", (void *) RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XML__LibXSLT__Processor_transform); /* prototype to pass -Wmissing-prototypes */
XS(XS_XML__LibXSLT__Processor_transform)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "processor, xml, ...");
    {
	xsltp_t *	processor;
	SV *	xml = ST(1);
#line 236 "Processor.xs"
        char               *buf, *key;
        int                 keylen, i, last_param, len;
        STRLEN              buf_len;
        TransformCtxt       transforms[MAX_TRANSFORMATIONS + 1];
        SV                 *params, *value;
        HV                 *hv;
        xmlDocPtr           xml_doc, tmp_doc = NULL;
        xsltp_result_t     *result;
#line 334 "Processor.c"
	xsltp_result_t *	RETVAL;

    if (sv_isa(ST(0), "XML::LibXSLT::Processor")) {
        IV tmp = SvIV((SV *) SvRV(ST(0)));
        processor = INT2PTR(xsltp_t *, tmp);
    } else
        Perl_croak(aTHX_ "%s: %s is not of type XML::LibXSLT::Processor",
            "XML::LibXSLT::Processor::transform",
            "processor");
#line 245 "Processor.xs"
        /* parse parameters */
        if (items < 3) {
            croak("Not enough parameters in transform()");
        }
        if (items > (MAX_TRANSFORMATIONS * 2 + 2)) {
            croak("Too many parameters in transform()");
        }

        if (xml == NULL || xml == &PL_sv_undef) {
            croak("XML document is undefined");
        }
        if (sv_derived_from(xml, "XML::LibXML::Node")) {
            xml_doc = (xmlDocPtr) x_PmmSvNode(xml);
            if (xml_doc == NULL) {
                XSRETURN_UNDEF;
            }
        }
        else {
            buf = SvPV(xml, buf_len);
            if (buf[0] == '<') {
                /* string */
                xml_doc = tmp_doc = xmlReadMemory(buf, buf_len, "noname.xml", NULL, 0);
                if (xml_doc == NULL) {
                    croak("Failed to parse XML document\n");
                }
            }
            else {
                /* file */
                xml_doc = tmp_doc = xmlParseFile(buf);
                if (xml_doc == NULL) {
                    croak("Failed to parse XML document\n");
                }
            }
        }

        for (i = 2; i < items; i = i + 2) {
            transforms[(i - 2) / 2].stylesheet = (char *) SvPV(ST(i), PL_na);
            transforms[(i - 2) / 2 + 1].stylesheet = 0;

            last_param = 0;
            if ((i + 1) < items) {
                params = ST(i + 1);
                if (SvTYPE(params) != SVt_NULL) {
                    if (!SvROK(params)) {
                        croak("Parameter is not reference\n");
                    }

                    hv  = (HV *) SvRV(params);
                    if (SvTYPE(hv) != SVt_PVHV) {
                        croak("Parameter is not hash reference\n");
                    }

                    len = HvUSEDKEYS(hv);
                    if (len > 0) {
                        if (len > (MAX_TRANSFORMATIONS_PARAMS - 1)) {
                            croak("Too many parameters in transform()");
                        }

                        hv_iterinit(hv);
                        while ((value = hv_iternextsv(hv, &key, &keylen))) {
                            transforms[(i - 2) / 2].params[last_param++] = key;
                            transforms[(i - 2) / 2].params[last_param++] = SvPV_nolen(value);
                        }
                    }
                }
            }

            transforms[(i - 2) / 2].params[last_param] = 0;
        }

        /* transform */
        result = NULL;
        for (i = 0; i < MAX_TRANSFORMATIONS; i++) {
            if (transforms[i].stylesheet == 0) {
                break;
            }

            if (result != NULL) {
                xml_doc = result->doc;
                result->doc = NULL;
                xsltp_result_destroy(result);
            }

            result = xsltp_transform(processor, transforms[i].stylesheet,
                xml_doc, (const char **) transforms[i].params);

            if (result == NULL) {
                croak("Failed to transform\n");
            }
        }
        if (tmp_doc != NULL) {
            xmlFreeDoc(tmp_doc);
        }

        RETVAL = result;
#line 440 "Processor.c"
	ST(0) = sv_newmortal();
    sv_setref_pv(ST(0), "XML::LibXSLT::Processor::Result", (void *) RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XML__LibXSLT__Processor_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_XML__LibXSLT__Processor_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "processor");
    {
	xsltp_t *	processor;

    if (sv_isa(ST(0), "XML::LibXSLT::Processor")) {
        IV tmp = SvIV((SV *) SvRV(ST(0)));
        processor = INT2PTR(xsltp_t *, tmp);
    } else
        Perl_croak(aTHX_ "%s: %s is not of type XML::LibXSLT::Processor",
            "XML::LibXSLT::Processor::DESTROY",
            "processor");
#line 347 "Processor.xs"
        xsltp_destroy(processor);
#line 470 "Processor.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XML__LibXSLT__Processor__Result_output_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_XML__LibXSLT__Processor__Result_output_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "result");
    {
	xsltp_result_t *	result;
#line 357 "Processor.xs"
        SV                 *results;
        xmlOutputBufferPtr  output;
        const xmlChar      *encoding = NULL;
        xmlCharEncodingHandlerPtr encoder = NULL;
#line 493 "Processor.c"
	SV *	RETVAL;

    if (sv_isa(ST(0), "XML::LibXSLT::Processor::Result")) {
        IV tmp = SvIV((SV *) SvRV(ST(0)));
        result = INT2PTR(xsltp_result_t *, tmp);
    } else
        Perl_croak(aTHX_ "%s: %s is not of type XML::LibXSLT::Processor::Result",
            "XML::LibXSLT::Processor::Result::output_string",
            "result");
#line 362 "Processor.xs"
        XSLT_GET_IMPORT_PTR(encoding, result->xsltp_stylesheet->stylesheet, encoding)
        if (encoding != NULL) {
            encoder = xmlFindCharEncodingHandler((char *)encoding);
            if ((encoder != NULL) &&
                (xmlStrEqual((const xmlChar *)encoder->name,
                          (const xmlChar *) "UTF-8"))) {
                encoder = NULL;
            }
        }
        results = newSVpv("", 0);
        output = xmlOutputBufferCreateIO(
            (xmlOutputWriteCallback) Processor_write_scalar,
            (xmlOutputCloseCallback) Processor_close_handler,
            (void *) results,
            encoder
        );
        if (xsltp_result_save(result, output) == -1) {
            croak("Output to scalar failed");
        }
        xmlOutputBufferClose(output);

        RETVAL = results;
#line 526 "Processor.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XML__LibXSLT__Processor__Result_output_fh); /* prototype to pass -Wmissing-prototypes */
XS(XS_XML__LibXSLT__Processor__Result_output_fh)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "result, fh");
    {
	xsltp_result_t *	result;
	void *	fh = INT2PTR(void *,SvIV(ST(1)));
#line 392 "Processor.xs"
        xmlOutputBufferPtr         output;
        const xmlChar             *encoding = NULL;
        xmlCharEncodingHandlerPtr  encoder = NULL;
        MAGIC                     *mg;
        PerlIO                    *fp;
        SV                        *obj;
        GV                        *gv = (GV *)fh;
        IO                        *io = GvIO(gv);
#line 556 "Processor.c"

    if (sv_isa(ST(0), "XML::LibXSLT::Processor::Result")) {
        IV tmp = SvIV((SV *) SvRV(ST(0)));
        result = INT2PTR(xsltp_result_t *, tmp);
    } else
        Perl_croak(aTHX_ "%s: %s is not of type XML::LibXSLT::Processor::Result",
            "XML::LibXSLT::Processor::Result::output_fh",
            "result");
#line 401 "Processor.xs"
        XSLT_GET_IMPORT_PTR(encoding, result->xsltp_stylesheet->stylesheet, encoding)
        if (encoding != NULL) {
            encoder = xmlFindCharEncodingHandler((char *)encoding);
            if ((encoder != NULL) &&
                (xmlStrEqual((const xmlChar *)encoder->name,
                          (const xmlChar *) "UTF-8"))) {
                encoder = NULL;
            }
        }

        if (io && (mg = SvTIED_mg((SV *)io, PERL_MAGIC_tiedscalar))) {
            /* tied handle */
            obj = SvTIED_obj(MUTABLE_SV(io), mg);

            output = xmlOutputBufferCreateIO(
                (xmlOutputWriteCallback) Processor_write_tied_handler,
                (xmlOutputCloseCallback) Processor_close_handler,
                obj,
                encoder
            );
        }
        else {
            /* simple handle */
            fp = IoOFP(io);

            output = xmlOutputBufferCreateIO(
                (xmlOutputWriteCallback) Processor_write_handler,
                (xmlOutputCloseCallback) Processor_close_handler,
                fp,
                encoder
            );
        }

        if (xsltp_result_save(result, output) == -1) {
            croak("Output to scalar failed");
        }

        xmlOutputBufferClose(output);
#line 604 "Processor.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XML__LibXSLT__Processor__Result_output_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_XML__LibXSLT__Processor__Result_output_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "result, filename");
    {
	xsltp_result_t *	result;
	char *	filename = (char *)SvPV_nolen(ST(1));

    if (sv_isa(ST(0), "XML::LibXSLT::Processor::Result")) {
        IV tmp = SvIV((SV *) SvRV(ST(0)));
        result = INT2PTR(xsltp_result_t *, tmp);
    } else
        Perl_croak(aTHX_ "%s: %s is not of type XML::LibXSLT::Processor::Result",
            "XML::LibXSLT::Processor::Result::output_file",
            "result");
#line 445 "Processor.xs"
        if (xsltp_result_save_to_file(result, filename) == -1) {
            croak("Output to file failed");
        }
#line 635 "Processor.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_XML__LibXSLT__Processor__Result_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_XML__LibXSLT__Processor__Result_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "result");
    {
	xsltp_result_t *	result;

    if (sv_isa(ST(0), "XML::LibXSLT::Processor::Result")) {
        IV tmp = SvIV((SV *) SvRV(ST(0)));
        result = INT2PTR(xsltp_result_t *, tmp);
    } else
        Perl_croak(aTHX_ "%s: %s is not of type XML::LibXSLT::Processor::Result",
            "XML::LibXSLT::Processor::Result::DESTROY",
            "result");
#line 453 "Processor.xs"
        xsltp_result_destroy(result);
#line 663 "Processor.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_XML__LibXSLT__Processor); /* prototype to pass -Wmissing-prototypes */
XS(boot_XML__LibXSLT__Processor)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("XML::LibXSLT::Processor::new", XS_XML__LibXSLT__Processor_new, file);
        newXS("XML::LibXSLT::Processor::transform", XS_XML__LibXSLT__Processor_transform, file);
        newXS("XML::LibXSLT::Processor::DESTROY", XS_XML__LibXSLT__Processor_DESTROY, file);
        newXS("XML::LibXSLT::Processor::Result::output_string", XS_XML__LibXSLT__Processor__Result_output_string, file);
        newXS("XML::LibXSLT::Processor::Result::output_fh", XS_XML__LibXSLT__Processor__Result_output_fh, file);
        newXS("XML::LibXSLT::Processor::Result::output_file", XS_XML__LibXSLT__Processor__Result_output_file, file);
        newXS("XML::LibXSLT::Processor::Result::DESTROY", XS_XML__LibXSLT__Processor__Result_DESTROY, file);
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

